using System.Text;

namespace ControlWorkbench.VEX.CodeGen;

/// <summary>
/// Generates PROS C++ code from ControlWorkbench configurations.
/// </summary>
public class ProsCodeGenerator
{
    private readonly StringBuilder _sb = new();
    private int _indentLevel = 0;

    /// <summary>
    /// Generate a complete PROS main.cpp with autonomous routine.
    /// </summary>
    public string GenerateMainCpp(
        RobotConfiguration config,
        List<Waypoint> autonomousPath,
        string teamName = "Team",
        string robotName = "Robot")
    {
        _sb.Clear();
        _indentLevel = 0;

        WriteHeader(teamName, robotName);
        WriteIncludes();
        WriteNamespace(config);
        WriteMotorDeclarations(config);
        WriteControllerDeclarations(config);
        WriteOdometryDeclarations(config);
        WriteInitialize();
        WriteDisabled();
        WriteCompetitionInitialize();
        WriteAutonomous(autonomousPath, config);
        WriteOpcontrol(config);

        return _sb.ToString();
    }

    /// <summary>
    /// Generate a header file with constants and configurations.
    /// </summary>
    public string GenerateConfigHeader(RobotConfiguration config)
    {
        _sb.Clear();
        _indentLevel = 0;

        WriteLine("// Auto-generated by ControlWorkbench");
        WriteLine("// Robot Configuration Header");
        WriteLine();
        WriteLine("#pragma once");
        WriteLine();
        WriteLine("#include \"api.h\"");
        WriteLine();
        WriteLine("namespace config {");
        _indentLevel++;

        // Motor ports
        WriteLine();
        WriteLine("// Motor Ports");
        foreach (var motor in config.Motors)
        {
            WriteLine($"constexpr int {motor.Name.ToUpper()}_PORT = {motor.Port};");
        }

        // Sensor ports
        if (config.Sensors.Any())
        {
            WriteLine();
            WriteLine("// Sensor Ports");
            foreach (var sensor in config.Sensors)
            {
                WriteLine($"constexpr int {sensor.Name.ToUpper()}_PORT = {sensor.Port};");
            }
        }

        // Drivetrain constants
        WriteLine();
        WriteLine("// Drivetrain Constants");
        WriteLine($"constexpr double WHEEL_DIAMETER = {config.WheelDiameter};  // inches");
        WriteLine($"constexpr double TRACK_WIDTH = {config.TrackWidth};  // inches");
        WriteLine($"constexpr double GEAR_RATIO = {config.GearRatio};");

        // PID constants
        if (config.PidConfigs.Any())
        {
            WriteLine();
            WriteLine("// PID Constants");
            foreach (var pid in config.PidConfigs)
            {
                WriteLine($"constexpr double {pid.Name.ToUpper()}_KP = {pid.Kp};");
                WriteLine($"constexpr double {pid.Name.ToUpper()}_KI = {pid.Ki};");
                WriteLine($"constexpr double {pid.Name.ToUpper()}_KD = {pid.Kd};");
            }
        }

        _indentLevel--;
        WriteLine();
        WriteLine("} // namespace config");

        return _sb.ToString();
    }

    /// <summary>
    /// Generate path following code for a set of waypoints.
    /// </summary>
    public string GeneratePathCode(List<Waypoint> path, string pathName = "auto_path")
    {
        _sb.Clear();
        _indentLevel = 0;

        WriteLine($"// Path: {pathName}");
        WriteLine($"// Generated by ControlWorkbench");
        WriteLine($"// Points: {path.Count}");
        WriteLine();
        WriteLine($"const std::vector<std::array<double, 3>> {pathName} = {{");
        _indentLevel++;

        for (int i = 0; i < path.Count; i++)
        {
            var wp = path[i];
            string comma = i < path.Count - 1 ? "," : "";
            WriteLine($"{{{wp.X:F2}, {wp.Y:F2}, {wp.Velocity:F2}}}{comma}");
        }

        _indentLevel--;
        WriteLine("};");

        return _sb.ToString();
    }

    /// <summary>
    /// Generate a PID controller class.
    /// </summary>
    public string GeneratePidClass()
    {
        _sb.Clear();
        
        WriteLine("// PID Controller - Generated by ControlWorkbench");
        WriteLine("#pragma once");
        WriteLine();
        WriteLine("class PIDController {");
        WriteLine("private:");
        _indentLevel++;
        WriteLine("double kP, kI, kD;");
        WriteLine("double integral = 0;");
        WriteLine("double prevError = 0;");
        WriteLine("double outputMin = -127;");
        WriteLine("double outputMax = 127;");
        _indentLevel--;
        WriteLine();
        WriteLine("public:");
        _indentLevel++;
        WriteLine("PIDController(double p, double i, double d) : kP(p), kI(i), kD(d) {}");
        WriteLine();
        WriteLine("double compute(double setpoint, double measurement, double dt) {");
        _indentLevel++;
        WriteLine("double error = setpoint - measurement;");
        WriteLine("integral += error * dt;");
        WriteLine("double derivative = (error - prevError) / dt;");
        WriteLine("prevError = error;");
        WriteLine();
        WriteLine("double output = kP * error + kI * integral + kD * derivative;");
        WriteLine("return std::clamp(output, outputMin, outputMax);");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("void setGains(double p, double i, double d) { kP = p; kI = i; kD = d; }");
        WriteLine("void setOutputLimits(double min, double max) { outputMin = min; outputMax = max; }");
        WriteLine("void reset() { integral = 0; prevError = 0; }");
        _indentLevel--;
        WriteLine("};");

        return _sb.ToString();
    }

    /// <summary>
    /// Generate odometry tracking code.
    /// </summary>
    public string GenerateOdometryClass(OdometryConfig config)
    {
        _sb.Clear();

        WriteLine("// Odometry Tracker - Generated by ControlWorkbench");
        WriteLine("#pragma once");
        WriteLine();
        WriteLine("#include <cmath>");
        WriteLine();
        WriteLine("class OdometryTracker {");
        WriteLine("private:");
        _indentLevel++;
        WriteLine("double x = 0, y = 0, theta = 0;");
        WriteLine("double prevLeft = 0, prevRight = 0, prevBack = 0;");
        WriteLine("bool initialized = false;");
        WriteLine();
        WriteLine($"static constexpr double TRACK_WIDTH = {config.TrackWidth};");
        WriteLine($"static constexpr double WHEEL_CIRCUMFERENCE = {config.WheelCircumference};");
        if (config.TrackingConfiguration == TrackingConfig.ThreeWheel)
        {
            WriteLine($"static constexpr double BACK_OFFSET = {config.BackOffset};");
        }
        _indentLevel--;
        WriteLine();
        WriteLine("public:");
        _indentLevel++;
        
        if (config.TrackingConfiguration == TrackingConfig.ThreeWheel)
        {
            WriteThreeWheelUpdate();
        }
        else
        {
            WriteTwoWheelUpdate();
        }

        WriteLine();
        WriteLine("void reset(double newX = 0, double newY = 0, double newTheta = 0) {");
        _indentLevel++;
        WriteLine("x = newX; y = newY; theta = newTheta;");
        WriteLine("initialized = false;");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("double getX() const { return x; }");
        WriteLine("double getY() const { return y; }");
        WriteLine("double getTheta() const { return theta; }");
        WriteLine("double getThetaDegrees() const { return theta * 180.0 / M_PI; }");

        _indentLevel--;
        WriteLine("};");

        return _sb.ToString();
    }

    /// <summary>
    /// Generate pure pursuit controller code.
    /// </summary>
    public string GeneratePurePursuitClass(double lookaheadDistance = 15.0)
    {
        _sb.Clear();

        WriteLine("// Pure Pursuit Controller - Generated by ControlWorkbench");
        WriteLine("#pragma once");
        WriteLine();
        WriteLine("#include <vector>");
        WriteLine("#include <array>");
        WriteLine("#include <cmath>");
        WriteLine();
        WriteLine("class PurePursuit {");
        WriteLine("private:");
        _indentLevel++;
        WriteLine("std::vector<std::array<double, 3>> path;  // x, y, velocity");
        WriteLine("size_t currentIndex = 0;");
        WriteLine("bool finished = false;");
        WriteLine($"static constexpr double LOOKAHEAD = {lookaheadDistance};");
        WriteLine("static constexpr double TRACK_WIDTH = 12.0;");
        _indentLevel--;
        WriteLine();
        WriteLine("public:");
        _indentLevel++;
        WriteLine("void setPath(const std::vector<std::array<double, 3>>& newPath) {");
        _indentLevel++;
        WriteLine("path = newPath;");
        WriteLine("currentIndex = 0;");
        WriteLine("finished = false;");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("std::pair<double, double> compute(double x, double y, double theta, double maxVel) {");
        _indentLevel++;
        WriteLine("if (path.empty() || finished) return {0, 0};");
        WriteLine();
        WriteLine("// Find lookahead point");
        WriteLine("auto [tx, ty, tv] = findLookahead(x, y);");
        WriteLine();
        WriteLine("// Calculate curvature");
        WriteLine("double dx = tx - x;");
        WriteLine("double dy = ty - y;");
        WriteLine("double localX = dx * cos(-theta) - dy * sin(-theta);");
        WriteLine("double localY = dx * sin(-theta) + dy * cos(-theta);");
        WriteLine("double L = sqrt(localX * localX + localY * localY);");
        WriteLine("double curvature = (L > 0.001) ? 2.0 * localX / (L * L) : 0;");
        WriteLine();
        WriteLine("double velocity = (tv > 0) ? tv : maxVel;");
        WriteLine("double left = velocity * (1 - curvature * TRACK_WIDTH / 2);");
        WriteLine("double right = velocity * (1 + curvature * TRACK_WIDTH / 2);");
        WriteLine();
        WriteLine("return {left, right};");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("bool isFinished() const { return finished; }");
        _indentLevel--;
        WriteLine();
        WriteLine("private:");
        _indentLevel++;
        WriteLine("std::array<double, 3> findLookahead(double x, double y) {");
        _indentLevel++;
        WriteLine("// Simplified: return point at lookahead distance");
        WriteLine("for (size_t i = currentIndex; i < path.size(); i++) {");
        _indentLevel++;
        WriteLine("double dist = sqrt(pow(path[i][0] - x, 2) + pow(path[i][1] - y, 2));");
        WriteLine("if (dist >= LOOKAHEAD) {");
        _indentLevel++;
        WriteLine("currentIndex = i;");
        WriteLine("return path[i];");
        _indentLevel--;
        WriteLine("}");
        _indentLevel--;
        WriteLine("}");
        WriteLine("finished = true;");
        WriteLine("return path.back();");
        _indentLevel--;
        WriteLine("}");
        _indentLevel--;
        WriteLine("};");

        return _sb.ToString();
    }

    #region Private Helpers

    private void WriteHeader(string teamName, string robotName)
    {
        WriteLine("/**");
        WriteLine($" * {teamName} - {robotName}");
        WriteLine(" * Generated by ControlWorkbench");
        WriteLine($" * Date: {DateTime.Now:yyyy-MM-dd HH:mm}");
        WriteLine(" */");
        WriteLine();
    }

    private void WriteIncludes()
    {
        WriteLine("#include \"main.h\"");
        WriteLine("#include <cmath>");
        WriteLine("#include <vector>");
        WriteLine("#include <array>");
        WriteLine();
    }

    private void WriteNamespace(RobotConfiguration config)
    {
        WriteLine("using namespace pros;");
        WriteLine();
    }

    private void WriteMotorDeclarations(RobotConfiguration config)
    {
        WriteLine("// Motors");
        foreach (var motor in config.Motors)
        {
            string reversed = motor.Reversed ? "true" : "false";
            string gearset = motor.Cartridge switch
            {
                MotorCartridge.Red => "E_MOTOR_GEARSET_36",
                MotorCartridge.Green => "E_MOTOR_GEARSET_18",
                MotorCartridge.Blue => "E_MOTOR_GEARSET_06",
                _ => "E_MOTOR_GEARSET_18"
            };
            WriteLine($"Motor {motor.Name}({motor.Port}, {gearset}, {reversed});");
        }
        WriteLine();
    }

    private void WriteControllerDeclarations(RobotConfiguration config)
    {
        WriteLine("// Controller");
        WriteLine("Controller master(E_CONTROLLER_MASTER);");
        WriteLine();
    }

    private void WriteOdometryDeclarations(RobotConfiguration config)
    {
        WriteLine("// Sensors");
        foreach (var sensor in config.Sensors)
        {
            string type = sensor.Type switch
            {
                "rotation" => "Rotation",
                "imu" => "Imu",
                "distance" => "Distance",
                "optical" => "Optical",
                "gps" => "Gps",
                _ => "ADIEncoder"
            };
            WriteLine($"{type} {sensor.Name}({sensor.Port});");
        }
        WriteLine();
    }

    private void WriteInitialize()
    {
        WriteLine("void initialize() {");
        _indentLevel++;
        WriteLine("lcd::initialize();");
        WriteLine("lcd::set_text(1, \"Initializing...\");");
        WriteLine();
        WriteLine("// Sensor calibration");
        WriteLine("// imu.reset();");
        WriteLine("// while (imu.is_calibrating()) { delay(10); }");
        WriteLine();
        WriteLine("lcd::set_text(1, \"Ready!\");");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
    }

    private void WriteDisabled()
    {
        WriteLine("void disabled() {}");
        WriteLine();
    }

    private void WriteCompetitionInitialize()
    {
        WriteLine("void competition_initialize() {}");
        WriteLine();
    }

    private void WriteAutonomous(List<Waypoint> path, RobotConfiguration config)
    {
        WriteLine("void autonomous() {");
        _indentLevel++;
        
        if (path.Any())
        {
            WriteLine("// Path waypoints: x (in), y (in), velocity");
            WriteLine("std::vector<std::array<double, 3>> path = {");
            _indentLevel++;
            for (int i = 0; i < path.Count; i++)
            {
                var wp = path[i];
                string comma = i < path.Count - 1 ? "," : "";
                WriteLine($"{{{wp.X:F2}, {wp.Y:F2}, {wp.Velocity:F2}}}{comma}");
            }
            _indentLevel--;
            WriteLine("};");
            WriteLine();
            WriteLine("// TODO: Implement path following");
            WriteLine("// purePursuit.setPath(path);");
            WriteLine("// while (!purePursuit.isFinished()) {");
            WriteLine("//     auto [left, right] = purePursuit.compute(odom.getX(), odom.getY(), odom.getTheta(), 100);");
            WriteLine("//     leftMotors.move(left);");
            WriteLine("//     rightMotors.move(right);");
            WriteLine("//     delay(10);");
            WriteLine("// }");
        }
        else
        {
            WriteLine("// TODO: Add autonomous routine");
        }
        
        _indentLevel--;
        WriteLine("}");
        WriteLine();
    }

    private void WriteOpcontrol(RobotConfiguration config)
    {
        WriteLine("void opcontrol() {");
        _indentLevel++;
        WriteLine("while (true) {");
        _indentLevel++;
        
        if (config.DrivetrainType == DrivetrainType.Tank)
        {
            WriteLine("// Tank drive");
            WriteLine("int left = master.get_analog(E_CONTROLLER_ANALOG_LEFT_Y);");
            WriteLine("int right = master.get_analog(E_CONTROLLER_ANALOG_RIGHT_Y);");
            WriteLine();
            WriteLine("// Apply to motors");
            WriteLine("// leftMotors.move(left);");
            WriteLine("// rightMotors.move(right);");
        }
        else if (config.DrivetrainType == DrivetrainType.Arcade)
        {
            WriteLine("// Arcade drive");
            WriteLine("int forward = master.get_analog(E_CONTROLLER_ANALOG_LEFT_Y);");
            WriteLine("int turn = master.get_analog(E_CONTROLLER_ANALOG_RIGHT_X);");
            WriteLine();
            WriteLine("int left = forward + turn;");
            WriteLine("int right = forward - turn;");
            WriteLine();
            WriteLine("// Apply to motors");
            WriteLine("// leftMotors.move(left);");
            WriteLine("// rightMotors.move(right);");
        }

        WriteLine();
        WriteLine("delay(10);");
        _indentLevel--;
        WriteLine("}");
        _indentLevel--;
        WriteLine("}");
    }

    private void WriteTwoWheelUpdate()
    {
        WriteLine("void update(double leftDeg, double rightDeg) {");
        _indentLevel++;
        WriteLine("if (!initialized) {");
        _indentLevel++;
        WriteLine("prevLeft = leftDeg;");
        WriteLine("prevRight = rightDeg;");
        WriteLine("initialized = true;");
        WriteLine("return;");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("double dLeft = (leftDeg - prevLeft) / 360.0 * WHEEL_CIRCUMFERENCE;");
        WriteLine("double dRight = (rightDeg - prevRight) / 360.0 * WHEEL_CIRCUMFERENCE;");
        WriteLine();
        WriteLine("double dTheta = (dRight - dLeft) / TRACK_WIDTH;");
        WriteLine("double dForward = (dLeft + dRight) / 2.0;");
        WriteLine();
        WriteLine("double avgTheta = theta + dTheta / 2.0;");
        WriteLine("x += dForward * sin(avgTheta);");
        WriteLine("y += dForward * cos(avgTheta);");
        WriteLine("theta += dTheta;");
        WriteLine();
        WriteLine("prevLeft = leftDeg;");
        WriteLine("prevRight = rightDeg;");
        _indentLevel--;
        WriteLine("}");
    }

    private void WriteThreeWheelUpdate()
    {
        WriteLine("void update(double leftDeg, double rightDeg, double backDeg) {");
        _indentLevel++;
        WriteLine("if (!initialized) {");
        _indentLevel++;
        WriteLine("prevLeft = leftDeg;");
        WriteLine("prevRight = rightDeg;");
        WriteLine("prevBack = backDeg;");
        WriteLine("initialized = true;");
        WriteLine("return;");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("double dLeft = (leftDeg - prevLeft) / 360.0 * WHEEL_CIRCUMFERENCE;");
        WriteLine("double dRight = (rightDeg - prevRight) / 360.0 * WHEEL_CIRCUMFERENCE;");
        WriteLine("double dBack = (backDeg - prevBack) / 360.0 * WHEEL_CIRCUMFERENCE;");
        WriteLine();
        WriteLine("double dTheta = (dRight - dLeft) / TRACK_WIDTH;");
        WriteLine();
        WriteLine("double localX, localY;");
        WriteLine("if (fabs(dTheta) < 1e-6) {");
        _indentLevel++;
        WriteLine("localX = dBack;");
        WriteLine("localY = (dLeft + dRight) / 2.0;");
        _indentLevel--;
        WriteLine("} else {");
        _indentLevel++;
        WriteLine("double radiusBack = dBack / dTheta;");
        WriteLine("localX = 2.0 * sin(dTheta / 2.0) * (radiusBack + BACK_OFFSET);");
        WriteLine("localY = 2.0 * sin(dTheta / 2.0) * ((dRight / dTheta) - TRACK_WIDTH / 2.0);");
        _indentLevel--;
        WriteLine("}");
        WriteLine();
        WriteLine("double avgTheta = theta + dTheta / 2.0;");
        WriteLine("x += localY * sin(avgTheta) + localX * cos(avgTheta);");
        WriteLine("y += localY * cos(avgTheta) - localX * sin(avgTheta);");
        WriteLine("theta += dTheta;");
        WriteLine();
        WriteLine("prevLeft = leftDeg;");
        WriteLine("prevRight = rightDeg;");
        WriteLine("prevBack = backDeg;");
        _indentLevel--;
        WriteLine("}");
    }

    private void WriteLine(string line = "")
    {
        if (string.IsNullOrEmpty(line))
        {
            _sb.AppendLine();
        }
        else
        {
            _sb.Append(new string(' ', _indentLevel * 4));
            _sb.AppendLine(line);
        }
    }

    #endregion
}

/// <summary>
/// Robot configuration for code generation.
/// </summary>
public class RobotConfiguration
{
    public string TeamNumber { get; set; } = "";
    public string RobotName { get; set; } = "Robot";
    
    public List<MotorConfig> Motors { get; set; } = new();
    public List<SensorConfig> Sensors { get; set; } = new();
    public List<PidConfig> PidConfigs { get; set; } = new();
    
    public DrivetrainType DrivetrainType { get; set; } = DrivetrainType.Tank;
    public double WheelDiameter { get; set; } = 4.0;
    public double TrackWidth { get; set; } = 12.0;
    public double GearRatio { get; set; } = 1.0;
}

public class MotorConfig
{
    public string Name { get; set; } = "";
    public int Port { get; set; }
    public MotorCartridge Cartridge { get; set; } = MotorCartridge.Green;
    public bool Reversed { get; set; }
    public string Group { get; set; } = ""; // e.g., "leftDrive", "rightDrive", "intake"
}

public class SensorConfig
{
    public string Name { get; set; } = "";
    public int Port { get; set; }
    public string Type { get; set; } = "rotation";
    public bool Reversed { get; set; }
}

public class PidConfig
{
    public string Name { get; set; } = "";
    public double Kp { get; set; }
    public double Ki { get; set; }
    public double Kd { get; set; }
}

public enum DrivetrainType
{
    Tank,
    Arcade,
    Curvature,
    Holonomic,
    XDrive,
    Mecanum
}
