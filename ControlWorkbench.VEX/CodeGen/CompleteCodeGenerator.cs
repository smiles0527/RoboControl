namespace ControlWorkbench.VEX.CodeGen;

/// <summary>
/// Complete robot code generator for PROS/VEXcode.
/// Generates entire project structure from configuration.
/// </summary>
public class RobotCodeGenerator
{
    public FullRobotConfig Config { get; set; } = new();
    public CodeStyle Style { get; set; } = CodeStyle.Pros;

    /// <summary>
    /// Generate complete PROS project.
    /// </summary>
    public Dictionary<string, string> GenerateProsProject()
    {
        var files = new Dictionary<string, string>();

        // Main robot files
        files["src/main.cpp"] = GenerateMainCpp();
        files["include/robot.hpp"] = GenerateRobotHeader();
        files["src/robot.cpp"] = GenerateRobotCpp();
        files["include/subsystems.hpp"] = GenerateSubsystemsHeader();
        files["src/subsystems.cpp"] = GenerateSubsystemsCpp();

        // Autonomous
        files["include/autons.hpp"] = GenerateAutonsHeader();
        files["src/autons.cpp"] = GenerateAutonsCpp();

        // Utilities
        files["include/pid.hpp"] = GeneratePidHeader();
        files["src/pid.cpp"] = GeneratePidCpp();

        // If using LemLib
        if (Config.UseLemLib)
        {
            files["include/lemlib_config.hpp"] = GenerateLemLibConfig();
        }

        return files;
    }

    private string GenerateMainCpp()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine(@"#include ""main.h""
#include ""robot.hpp""
#include ""autons.hpp""

/**
 * Robot code generated by ControlWorkbench
 * Team: " + Config.TeamNumber + @"
 * Robot: " + Config.RobotName + @"
 * Generated: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm") + @"
 */

void initialize() {
    robot::initialize();
");

        if (Config.UseLemLib)
        {
            sb.AppendLine("    chassis.calibrate();");
        }
        else
        {
            sb.AppendLine("    robot::imu.reset();");
            sb.AppendLine("    while (robot::imu.is_calibrating()) {");
            sb.AppendLine("        pros::delay(10);");
            sb.AppendLine("    }");
        }

        sb.AppendLine(@"
    // Set up auton selector
    auton::selector.add_autons({
        {""Do Nothing"", auton::do_nothing},
        {""Red Positive"", auton::red_positive},
        {""Red Negative"", auton::red_negative},
        {""Blue Positive"", auton::blue_positive},
        {""Blue Negative"", auton::blue_negative},
        {""Skills"", auton::skills}
    });
}

void disabled() {}

void competition_initialize() {}

void autonomous() {
    auton::selector.run_selected_auton();
}

void opcontrol() {
    while (true) {
        // Drivetrain control
        robot::drive_tank();
        // OR: robot::drive_arcade();

        // Subsystem control
        robot::intake_control();
        robot::pneumatics_control();

        pros::delay(10);
    }
}");

        return sb.ToString();
    }

    private string GenerateRobotHeader()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine(@"#pragma once
#include ""pros/motors.hpp""
#include ""pros/imu.hpp""
#include ""pros/rotation.hpp""
#include ""pros/distance.hpp""
#include ""pros/optical.hpp""
#include ""pros/adi.hpp""");

        if (Config.UseLemLib)
        {
            sb.AppendLine(@"#include ""lemlib/api.hpp""");
        }

        sb.AppendLine(@"
namespace robot {

// Motor ports");

        // Generate motor declarations
        foreach (var motor in Config.Motors)
        {
            sb.AppendLine($"constexpr int {motor.Name.ToUpper()}_PORT = {motor.Port};");
        }

        sb.AppendLine(@"
// Sensor ports");

        foreach (var sensor in Config.Sensors)
        {
            sb.AppendLine($"constexpr int {sensor.Name.ToUpper()}_PORT = {sensor.Port};");
        }

        sb.AppendLine(@"
// ADI ports");

        foreach (var adi in Config.AdiDevices)
        {
            sb.AppendLine($"constexpr char {adi.Name.ToUpper()}_PORT = '{adi.Port}';");
        }

        sb.AppendLine(@"
// Motor groups
extern pros::MotorGroup left_drive;
extern pros::MotorGroup right_drive;");

        foreach (var group in Config.MotorGroups)
        {
            if (group.Name != "left_drive" && group.Name != "right_drive")
            {
                sb.AppendLine($"extern pros::MotorGroup {group.Name};");
            }
        }

        sb.AppendLine(@"
// Sensors
extern pros::Imu imu;");

        foreach (var sensor in Config.Sensors)
        {
            string type = sensor.Type switch
            {
                SensorType.Rotation => "pros::Rotation",
                SensorType.Distance => "pros::Distance",
                SensorType.Optical => "pros::Optical",
                SensorType.Gps => "pros::Gps",
                _ => "pros::Imu"
            };
            sb.AppendLine($"extern {type} {sensor.Name};");
        }

        sb.AppendLine(@"
// Pneumatics");
        foreach (var adi in Config.AdiDevices.Where(a => a.Type == AdiDeviceType.Pneumatic))
        {
            sb.AppendLine($"extern pros::adi::Pneumatics {adi.Name};");
        }

        if (Config.UseLemLib)
        {
            sb.AppendLine(@"
// LemLib chassis
extern lemlib::Chassis chassis;");
        }

        sb.AppendLine(@"
// Functions
void initialize();
void drive_tank();
void drive_arcade();
void intake_control();
void pneumatics_control();

} // namespace robot");

        return sb.ToString();
    }

    private string GenerateRobotCpp()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine(@"#include ""robot.hpp""
#include ""pros/misc.hpp""

namespace robot {

// Controller
pros::Controller master(pros::E_CONTROLLER_MASTER);

// Motors");

        // Generate motor definitions
        var leftPorts = Config.Motors.Where(m => m.Group == "left_drive").Select(m => m.Reversed ? -m.Port : m.Port);
        var rightPorts = Config.Motors.Where(m => m.Group == "right_drive").Select(m => m.Reversed ? -m.Port : m.Port);

        sb.AppendLine($"pros::MotorGroup left_drive({{{string.Join(", ", leftPorts)}}}, pros::MotorGearset::{Config.DriveGearset});");
        sb.AppendLine($"pros::MotorGroup right_drive({{{string.Join(", ", rightPorts)}}}, pros::MotorGearset::{Config.DriveGearset});");

        foreach (var group in Config.MotorGroups.Where(g => g.Name != "left_drive" && g.Name != "right_drive"))
        {
            var ports = Config.Motors.Where(m => m.Group == group.Name).Select(m => m.Reversed ? -m.Port : m.Port);
            sb.AppendLine($"pros::MotorGroup {group.Name}({{{string.Join(", ", ports)}}}, pros::MotorGearset::{group.Gearset});");
        }

        sb.AppendLine(@"
// Sensors");
        sb.AppendLine($"pros::Imu imu({Config.ImuPort});");

        foreach (var sensor in Config.Sensors)
        {
            string type = sensor.Type switch
            {
                SensorType.Rotation => "pros::Rotation",
                SensorType.Distance => "pros::Distance",
                SensorType.Optical => "pros::Optical",
                _ => "pros::Imu"
            };
            sb.AppendLine($"{type} {sensor.Name}({sensor.Port});");
        }

        sb.AppendLine(@"
// Pneumatics");
        foreach (var adi in Config.AdiDevices.Where(a => a.Type == AdiDeviceType.Pneumatic))
        {
            sb.AppendLine($"pros::adi::Pneumatics {adi.Name}('{adi.Port}', false);");
        }

        if (Config.UseLemLib)
        {
            sb.AppendLine(GenerateLemLibChassis());
        }

        sb.AppendLine(@"
void initialize() {
    left_drive.set_brake_mode(pros::E_MOTOR_BRAKE_COAST);
    right_drive.set_brake_mode(pros::E_MOTOR_BRAKE_COAST);
}

void drive_tank() {
    int left_power = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
    int right_power = master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y);
    
    // Apply deadband
    if (std::abs(left_power) < 5) left_power = 0;
    if (std::abs(right_power) < 5) right_power = 0;
    
    left_drive.move(left_power);
    right_drive.move(right_power);
}

void drive_arcade() {
    int forward = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);
    int turn = master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X);
    
    // Apply deadband
    if (std::abs(forward) < 5) forward = 0;
    if (std::abs(turn) < 5) turn = 0;
    
    left_drive.move(forward + turn);
    right_drive.move(forward - turn);
}
");

        // Generate intake control
        sb.AppendLine(@"void intake_control() {");
        var intakeGroup = Config.MotorGroups.FirstOrDefault(g => g.Name.Contains("intake"));
        if (intakeGroup != null)
        {
            sb.AppendLine($@"    if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {{
        {intakeGroup.Name}.move(127);
    }} else if (master.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {{
        {intakeGroup.Name}.move(-127);
    }} else {{
        {intakeGroup.Name}.move(0);
    }}");
        }
        sb.AppendLine("}");

        // Generate pneumatics control
        sb.AppendLine(@"
void pneumatics_control() {");
        foreach (var adi in Config.AdiDevices.Where(a => a.Type == AdiDeviceType.Pneumatic))
        {
            sb.AppendLine($@"    if (master.get_digital_new_press({adi.ButtonBinding})) {{
        {adi.Name}.toggle();
    }}");
        }
        sb.AppendLine("}");

        sb.AppendLine(@"
} // namespace robot");

        return sb.ToString();
    }

    private string GenerateSubsystemsHeader()
    {
        return @"#pragma once

namespace subsystems {

class Intake {
public:
    void run(int power);
    void stop();
    void set_color_sorting(bool enabled);
private:
    bool color_sorting_enabled = false;
};

class Lift {
public:
    void move_to(double position);
    void manual_control(int power);
    bool is_at_target();
private:
    double target_position = 0;
};

class MogoClamp {
public:
    void extend();
    void retract();
    void toggle();
    bool is_extended();
private:
    bool extended = false;
};

extern Intake intake;
extern Lift lift;
extern MogoClamp mogo_clamp;

} // namespace subsystems";
    }

    private string GenerateSubsystemsCpp()
    {
        return @"#include ""subsystems.hpp""
#include ""robot.hpp""

namespace subsystems {

Intake intake;
Lift lift;
MogoClamp mogo_clamp;

void Intake::run(int power) {
    // Implementation depends on robot config
}

void Intake::stop() {
    run(0);
}

void Intake::set_color_sorting(bool enabled) {
    color_sorting_enabled = enabled;
}

void Lift::move_to(double position) {
    target_position = position;
    // PID control implementation
}

void Lift::manual_control(int power) {
    // Direct motor control
}

bool Lift::is_at_target() {
    // Check if within tolerance
    return true;
}

void MogoClamp::extend() {
    extended = true;
    // Actuate pneumatic
}

void MogoClamp::retract() {
    extended = false;
    // Actuate pneumatic
}

void MogoClamp::toggle() {
    if (extended) retract();
    else extend();
}

bool MogoClamp::is_extended() {
    return extended;
}

} // namespace subsystems";
    }

    private string GenerateAutonsHeader()
    {
        return @"#pragma once
#include ""EZ-Template/api.hpp""

namespace auton {

extern ez::AutonSelector selector;

void do_nothing();
void red_positive();
void red_negative();
void blue_positive();
void blue_negative();
void skills();

// Motion functions
void drive_distance(double inches, int max_speed = 110);
void turn_to_heading(double heading, int max_speed = 90);
void drive_to_point(double x, double y, int max_speed = 110);
void score_on_stake();
void grab_mogo();
void release_mogo();

} // namespace auton";
    }

    private string GenerateAutonsCpp()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine(@"#include ""autons.hpp""
#include ""robot.hpp""
#include ""subsystems.hpp""

namespace auton {

ez::AutonSelector selector;

void do_nothing() {
    // Safety auton
}

void red_positive() {
    // Red alliance, positive corner side
    
    // Score preload on alliance stake
    drive_distance(12);
    score_on_stake();
    
    // Grab mobile goal
    drive_distance(-24);
    turn_to_heading(90);
    drive_distance(24);
    grab_mogo();
    
    // Score rings
    drive_distance(-12);
    // Add more scoring
    
    // Place in corner
    drive_to_point(12, 12);
    release_mogo();
}

void red_negative() {
    // Red alliance, negative corner side
    // Mirror of red_positive with different targets
}

void blue_positive() {
    // Blue alliance, positive corner side
    // Mirror of red_negative
}

void blue_negative() {
    // Blue alliance, negative corner side
    // Mirror of red_positive
}

void skills() {
    // 60-second autonomous skills run
    // Optimized for maximum points
    
    // Score preload
    score_on_stake();
    
    // First mobile goal cycle
    grab_mogo();
    // Score rings...
    drive_to_point(12, 12);
    release_mogo();
    
    // Continue with more cycles...
}

// Motion implementations");

        if (Config.UseLemLib)
        {
            sb.AppendLine(@"
void drive_distance(double inches, int max_speed) {
    robot::chassis.moveToPoint(0, inches, 5000, {.maxSpeed = max_speed});
    robot::chassis.waitUntilDone();
}

void turn_to_heading(double heading, int max_speed) {
    robot::chassis.turnToHeading(heading, 3000, {.maxSpeed = max_speed});
    robot::chassis.waitUntilDone();
}

void drive_to_point(double x, double y, int max_speed) {
    robot::chassis.moveToPoint(x, y, 5000, {.maxSpeed = max_speed});
    robot::chassis.waitUntilDone();
}");
        }
        else
        {
            sb.AppendLine(@"
void drive_distance(double inches, int max_speed) {
    // Basic PID implementation
    double target = robot::left_drive.get_position() + inches * " + (360.0 / (Config.WheelDiameter * Math.PI)).ToString("F2") + @";
    // Add PID loop
}

void turn_to_heading(double heading, int max_speed) {
    // Basic turn implementation
}

void drive_to_point(double x, double y, int max_speed) {
    // Pure pursuit or basic point-to-point
}");
        }

        sb.AppendLine(@"
void score_on_stake() {
    subsystems::intake.run(127);
    pros::delay(500);
    subsystems::intake.stop();
}

void grab_mogo() {
    subsystems::mogo_clamp.extend();
    pros::delay(200);
}

void release_mogo() {
    subsystems::mogo_clamp.retract();
    pros::delay(200);
}

} // namespace auton");

        return sb.ToString();
    }

    private string GeneratePidHeader()
    {
        return @"#pragma once

class PID {
public:
    PID(double kP, double kI, double kD, double integralMax = 1000);
    
    double compute(double error);
    double compute(double target, double current);
    void reset();
    void set_gains(double kP, double kI, double kD);
    
    bool is_settled(double tolerance = 1.0, int settle_time_ms = 100);

private:
    double kP, kI, kD;
    double integral = 0;
    double prev_error = 0;
    double integral_max;
    
    int settle_count = 0;
    int settle_threshold;
};";
    }

    private string GeneratePidCpp()
    {
        return @"#include ""pid.hpp""
#include <cmath>

PID::PID(double kP, double kI, double kD, double integralMax)
    : kP(kP), kI(kI), kD(kD), integral_max(integralMax) {}

double PID::compute(double error) {
    // Proportional
    double p = kP * error;
    
    // Integral with anti-windup
    integral += error;
    if (std::abs(integral) > integral_max) {
        integral = (integral > 0 ? 1 : -1) * integral_max;
    }
    double i = kI * integral;
    
    // Derivative
    double d = kD * (error - prev_error);
    prev_error = error;
    
    return p + i + d;
}

double PID::compute(double target, double current) {
    return compute(target - current);
}

void PID::reset() {
    integral = 0;
    prev_error = 0;
    settle_count = 0;
}

void PID::set_gains(double kP, double kI, double kD) {
    this->kP = kP;
    this->kI = kI;
    this->kD = kD;
}

bool PID::is_settled(double tolerance, int settle_time_ms) {
    if (std::abs(prev_error) < tolerance) {
        settle_count += 10; // Assuming 10ms loop
        return settle_count >= settle_time_ms;
    }
    settle_count = 0;
    return false;
}";
    }

    private string GenerateLemLibConfig()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine($@"#pragma once
#include ""lemlib/api.hpp""

// Drivetrain settings for team {Config.TeamNumber}
// Robot: {Config.RobotName}

// Track width and wheel diameter
constexpr double TRACK_WIDTH = {Config.TrackWidth};
constexpr double WHEEL_DIAMETER = {Config.WheelDiameter};
constexpr double DRIVETRAIN_RPM = {(int)Config.DriveRpm};

// Horizontal tracking wheel (if used)
constexpr double HORIZONTAL_WHEEL_OFFSET = {Config.HorizontalTrackerOffset};

// PID gains (tune these!)
lemlib::ControllerSettings lateral_controller {{
    10,   // kP
    0,    // kI
    3,    // kD
    3,    // anti-windup
    1,    // small error range (inches)
    100,  // small error timeout (ms)
    3,    // large error range (inches)
    500,  // large error timeout (ms)
    20    // slew rate
}};

lemlib::ControllerSettings angular_controller {{
    2,    // kP
    0,    // kI
    10,   // kD
    3,    // anti-windup
    1,    // small error range (degrees)
    100,  // small error timeout (ms)
    3,    // large error range (degrees)
    500,  // large error timeout (ms)
    0     // slew rate
}};");

        return sb.ToString();
    }

    private string GenerateLemLibChassis()
    {
        return $@"
// LemLib drivetrain configuration
lemlib::Drivetrain drivetrain {{
    &left_drive,
    &right_drive,
    {Config.TrackWidth},
    lemlib::Omniwheel::NEW_{(int)(Config.WheelDiameter * 10):D2},
    {(int)Config.DriveRpm},
    2
}};

lemlib::OdomSensors sensors {{
    nullptr, // vertical tracking wheel 1
    nullptr, // vertical tracking wheel 2
    nullptr, // horizontal tracking wheel
    nullptr, // horizontal tracking wheel 2
    &imu
}};

lemlib::Chassis chassis(drivetrain, lateral_controller, angular_controller, sensors);";
    }
}

/// <summary>
/// Extended robot configuration with full project details.
/// </summary>
public class FullRobotConfig
{
    public string TeamNumber { get; set; } = "00000X";
    public string RobotName { get; set; } = "Competition Robot";

    // Drivetrain
    public double WheelDiameter { get; set; } = 3.25;
    public double TrackWidth { get; set; } = 12.0;
    public double DriveRpm { get; set; } = 600;
    public string DriveGearset { get; set; } = "blue";
    public int ImuPort { get; set; } = 10;

    // Tracking wheels
    public double HorizontalTrackerOffset { get; set; } = 5.0;
    public int LeftTrackerPort { get; set; }
    public int RightTrackerPort { get; set; }
    public int HorizontalTrackerPort { get; set; }

    // Library choice
    public bool UseLemLib { get; set; } = true;
    public bool UseEzTemplate { get; set; } = false;

    // Motors
    public List<ExtendedMotorConfig> Motors { get; } = new();
    public List<MotorGroupConfig> MotorGroups { get; } = new();

    // Sensors
    public List<ExtendedSensorConfig> Sensors { get; } = new();

    // ADI devices
    public List<AdiDeviceConfig> AdiDevices { get; } = new();

    /// <summary>
    /// Create a standard 6-motor drivetrain configuration.
    /// </summary>
    public static FullRobotConfig Create6MotorBase()
    {
        var config = new FullRobotConfig();

        // Left drive motors
        config.Motors.Add(new ExtendedMotorConfig { Port = 1, Name = "left_front", Group = "left_drive", Reversed = true });
        config.Motors.Add(new ExtendedMotorConfig { Port = 2, Name = "left_middle", Group = "left_drive", Reversed = true });
        config.Motors.Add(new ExtendedMotorConfig { Port = 3, Name = "left_back", Group = "left_drive", Reversed = true });

        // Right drive motors
        config.Motors.Add(new ExtendedMotorConfig { Port = 4, Name = "right_front", Group = "right_drive", Reversed = false });
        config.Motors.Add(new ExtendedMotorConfig { Port = 5, Name = "right_middle", Group = "right_drive", Reversed = false });
        config.Motors.Add(new ExtendedMotorConfig { Port = 6, Name = "right_back", Group = "right_drive", Reversed = false });

        config.MotorGroups.Add(new MotorGroupConfig { Name = "left_drive", Gearset = "blue" });
        config.MotorGroups.Add(new MotorGroupConfig { Name = "right_drive", Gearset = "blue" });

        return config;
    }

    /// <summary>
    /// Add an intake subsystem.
    /// </summary>
    public void AddIntake(int port, bool reversed = false)
    {
        Motors.Add(new ExtendedMotorConfig { Port = port, Name = "intake", Group = "intake", Reversed = reversed });
        MotorGroups.Add(new MotorGroupConfig { Name = "intake", Gearset = "green" });
    }

    /// <summary>
    /// Add a lift subsystem.
    /// </summary>
    public void AddLift(int[] ports, bool[] reversed)
    {
        for (int i = 0; i < ports.Length; i++)
        {
            Motors.Add(new ExtendedMotorConfig
            {
                Port = ports[i],
                Name = $"lift_{i + 1}",
                Group = "lift",
                Reversed = reversed[i]
            });
        }
        MotorGroups.Add(new MotorGroupConfig { Name = "lift", Gearset = "red" });
    }

    /// <summary>
    /// Add a pneumatic device.
    /// </summary>
    public void AddPneumatic(char port, string name, string buttonBinding = "pros::E_CONTROLLER_DIGITAL_L1")
    {
        AdiDevices.Add(new AdiDeviceConfig
        {
            Port = port,
            Name = name,
            Type = AdiDeviceType.Pneumatic,
            ButtonBinding = buttonBinding
        });
    }
}

public class ExtendedMotorConfig
{
    public int Port { get; set; }
    public string Name { get; set; } = "";
    public string Group { get; set; } = "";
    public bool Reversed { get; set; }
}

public class MotorGroupConfig
{
    public string Name { get; set; } = "";
    public string Gearset { get; set; } = "green";
}

public class ExtendedSensorConfig
{
    public int Port { get; set; }
    public string Name { get; set; } = "";
    public SensorType Type { get; set; }
}

public enum SensorType
{
    Imu,
    Rotation,
    Distance,
    Optical,
    Vision,
    Gps
}

public class AdiDeviceConfig
{
    public char Port { get; set; }
    public string Name { get; set; } = "";
    public AdiDeviceType Type { get; set; }
    public string ButtonBinding { get; set; } = "";
}

public enum AdiDeviceType
{
    Pneumatic,
    Encoder,
    Ultrasonic,
    LineSensor,
    Potentiometer,
    DigitalIn,
    DigitalOut
}

public enum CodeStyle
{
    Pros,
    VexCode,
    ProsWithLemLib,
    ProsWithEzTemplate
}
